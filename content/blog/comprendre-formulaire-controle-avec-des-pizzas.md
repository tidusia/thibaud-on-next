---
title: "React : comprendre le formulaire contr√¥l√© avec des Pizzas"
date: "2021-06-02"
excerpt: "Un dev vous parle de formulaire contr√¥l√© ? Vous aimeriez bien savoir de quel genre d'animal il s'agit ?"
picture: "/images/blog/skating-pizzas.jpg"
pictureAlt: Un dev react livrant des pizzas (non-controll√©es) en skate. Illustration [Micka√´l Merley](https://mickaelmerley.com/)
---

Cet article est destin√© aux d√©veloppeurs front junior ou √† toute personne qui travaille avec un dev front qui lui parle de cet √©trange animal qu'est le **formulaire contr√¥l√©**.

C'est aussi destin√© √† quiconque aime discuter de pizzas, pour qui tous les pr√©textes sont bons.

Aucun pr√©requis pour suivre cet article qui se veut tout public, mais des √©l√©ments de pr√©cision technique seront donn√©s pour les connaisseurs.

## Commen√ßons avec la base : le formulaire HTML

L'id√©e est simple, Marcel veut commander une pizza. Il doit indiquer :

- son nom
- la pizza souhait√©e parmi un choix d√©termin√©
- et, s‚Äôil choisit la pizza "Reine", avoir la possibilit√© d'y ajouter un oeuf.

Au sein d'une application react, mais en se contentant uniquement du HTML, √ßa donnerait quelque chose de ce genre :

```tsx
import React, { FunctionComponent } from "react";
import styles from "../forms.module.css";

export type PizzaFormProps = Record<string, never>;

const PizzaForm: FunctionComponent<PizzaFormProps> = () => (
  <form className={styles.form}>
    <label htmlFor="prenom">Quel est votre pr√©nom ?</label>
    <input id="prenom" name="prenom" required />

    <label htmlFor="pizza">Quelle pizza d√©sirez-vous</label>
    <select name="pizza" id="pizza">
      <option value="fromage">Fromage</option>
      <option value="reine">Reine</option>
      <option value="veggie">Veggie</option>
    </select>

    <label htmlFor="oeuf">
      <input type="checkbox" name="oeuf" id="oeuf" />
      Si vous avez choisi la Reine, d√©sirez-vous un bel oeuf dessus en prime ?
    </label>

    <input type="submit" value="Commander !" />
  </form>
);

export default PizzaForm;
```

Et √ßa, mesdames et messieurs, **c'est un formulaire totalement NON contr√¥l√©**. Car actuellement, en tant que dev, je n'ai aucune mainmise sur les valeurs entr√©es par Marcel, et je d√©l√®gue tout au navigateur : garder la trace des valeurs dans les inputs, g√©rer les validations, soumettre vers le serveur... C'est le navigateur le boss.

Et dans pas mal de cas, √ßa peut largement suffire ! Un excellent exemple : le formulaire de contact. Et m√™me dans des cas plus complets avec upload de fichiers, champs de recherche avec pr√©remplissage, et j'en passe. √áa fait tr√®s bien le job.

Pour ceux qui d√©butent en HTML :

- La balise `<form>` englobe tout ce qui fera partit du formulaire. On verra plus tard son importance.
- Chaque champ doit avoir un `name` qui est le nom que le dev attache √† la valeur entr√©e par Marcel. `<input name="prenom" />` permettra d'acc√©der au pr√©nom que l'utilisateur aura saisi via la cl√© `prenom`.
- Les champs ont aussi un `id`, g√©n√©ralement le m√™me que le `name` (mais pas toujours). Cet `id` unique permet de le lier √† un label via son `htmlFor`. Ainsi, cliquer sur "Quel est votre nom ?" pointera sur le champ `nom`.
- l'attribut `required` indique qu'on veut absolument avoir une valeur entr√©e dans ce champ. Il est donc obligatoire d'entrer un pr√©nom si l'on d√©sire que le navigateur daigne soumettre le formulaire.

> Un oeil avertit aura remarqu√© l'usage de `htmlFor` en lieu et place de `for`, c'est d√ª au fait que `for` est un mot-cl√© r√©serv√© en JavaScript, et que la mani√®re dont react est con√ßu ne permet pas d'utiliser ces mots-cl√©s en nom d'attributs. La m√™me chose existe pour `class` qui devient `className`.

Cependant, cette fa√ßon de faire, aussi simple soit-elle, va avoir quelques limitations :

- Soumettre ce formulaire (en gros, appuyer sur "Commander !"), provoque un rechargement de la page. Sans fournir plus d'indications que √ßa, le formulaire va rediriger sur cette m√™me page, mais en passant en param√®tre les informations remplies. Un rechargement de page sur une application react est une op√©ration couteuse, tout est fait pour ne pas en avoir besoin.
- On affiche assez inutilement la checkbox pour l'oeuf dans 2 cas sur 3, on aimerait un syst√®me qui n'affiche cette option que lorsque Marcel a choisi une Pizza "Reine"
- Le bouton "Commander !" est cliquable d'entr√©e de jeu, m√™me si le formulaire n'est pas valide, on aimerait le griser tant qu'on n‚Äôest pas s√ªr que Marcel ait bien entr√© son pr√©nom.

Et sauf cas sp√©ciaux, c'est g√©n√©ralement pour cette raison qu'on veut passer √† un formulaire contr√¥l√© : am√©liorer (ou du moins changer) l'exp√©rience qu'aura Marcel. Avoir le contr√¥le dessus. Et tant pis pour le navigateur.

## Contr√¥ler la soumission du formulaire

Pour √©viter le d√©sagr√©ment du rechargement de page, pr√©parez votre machine √† laver, car on va avoir l'honneur de sortir les **requ√™tes AJAX.**

AJAX signifie [AJAX (Asynchronous JavaScript + XML)](https://developer.mozilla.org/fr/docs/Web/Guide/AJAX) et concr√®tement √ßa va nous permettre d'envoyer √† un serveur les informations que Marcel a saisies, de recevoir un bel accus√© de r√©ception, et de d√©cider quoi faire apr√®s √ßa, le tout, sans quitter la page, ni son canap√©.

Et avec √ßa, vous n'avez pas du linge plus blanc que blanc, [vous avez toujours le nouvel OMO](https://youtu.be/VEZw1Vmq97Y?t=77).

Voici le code √† ajouter pour court-circuiter le navigateur et contr√¥ler nous-m√™mes ce que nous ferons des donn√©es entr√©es par l'utilisateur :

```tsx
<form
  onSubmit={(event) => {
    event.preventDefault();
    const body = buildPayloadFromSubmit(event);
    axios
      .post("https://pizza-api.example.com", body)
      .then((response) => alert(`Commande envoy√©e ! ${response}`))
      .catch((error) => alert(`Outch ! Petit souci : ${error}`));
  }}
>
  {/* ... reste du formulaire ... */}
</form>
```

Point par point, √ßa donne :

- `onSubmit` est un attribut qui nous permet d'√©couter l'√©v√®nement `submit` du formulaire, lorsqu'il se produit, le code qu'on lui aura donn√© sera ex√©cut√© en passant un pr√©cieux param√®tre `event`
- `event` est tr√®s important, il repr√©sente "l'√©v√®nement" du submit. On peut le manipuler pour r√©cup√©rer des infos ou court-circuiter le comportement par d√©faut du navigateur, √† savoir : le rechargement de la page. C'est ainsi repr√©sent√© par le code `event.preventDefault()`
- Ensuite, on a besoin de r√©cup√©rer les entr√©es de Marcel √† partir de cet √©v√®nement. Pour cela, je passe l'√©v√®nement dans une petite moulinette qui va me retourner un bel objet avec toutes les valeurs bien emball√©es comme il faut, pr√™t √† peser et √† exp√©dier en colissimo au serveur. Pour les petits curieux, le d√©tail de cette fonction est donn√© plus bas.
- Une fois que j'ai tout emball√©, il me reste √† remplir le recommand√©. Il me faut donc une adresse (du serveur), soit `"https://pizza-api.example.com"`, puis j'utilise une lib bien sympa, `axios` qui me permet de vous √©viter toute la verbosit√© possible des requ√™tes AJAX et de faire comme si c'√©tait simple üòÖ et je n'oublie pas de lui passer les d√©tails de la commande, qu'on appelle g√©n√©ralement le `body`
- √áa y est ! C'est parti ! S‚Äôil n'y a pas trop de bouchons sur le p√©rif, je devrais avoir ma r√©ponse en moins d'une seconde. Et pour r√©cup√©rer cette r√©ponse, je vais utiliser `then` et `catch`. `then` sera appel√© dans le cas o√π √ßa a fonctionn√©, que tout va bien. Il me transmet une r√©ponse et j'en fais ce que j'en veux ! La forme de la r√©ponse `response` est enti√®rement d√©pendant : et de la lib utilis√©e pour la requ√™te (ici axios) et du serveur. Pour cette d√©mo, on va faire comme si c'√©tait juste un petit message sympa, qu'on affiche en plus d'un texte "en dur" √† Marcel via le `alert`.
- Par contre, si √ßa va mal, c'est le `catch` qui va √™tre appel√©, et qui va passer une `error` qu'on va aussi juste afficher par simplicit√©

```tsx
// La magie derri√®re buildPayloadFromSubmit
import React from "react";

type Payload = { [key: string]: any };

export default function buildPayloadFromSubmit(
  event: React.FormEvent<HTMLFormElement>,
): Payload {
  const userFormData = new FormData(event.currentTarget);
  const userEntries = Array.from(userFormData.entries());
  const payload: Payload = {};
  userEntries.forEach((entry) => (payload[entry[0]] = entry[1]));
  return payload;
}
```

√áa y est ! Alors, il est bien contr√¥l√© maintenant ce formulaire ?

Et bien, pas vraiment. On a juste attrap√© au vol la soumission, mais nos champs sont toujours entre les griffes du navigateur, tel Golum avec son _pr√©cieux..._

La prochaine feature va nous permettre de commencer √† mieux mater ce formulaire.

## Masquer la checkbox de mani√®re conditionnelle

Pour savoir en temps r√©el ce qu'est en train de choisir Marcel dans son petit formulaire, on va avoir besoin d'un syst√®me pour stocker les valeurs des diff√©rents champs. Ce syst√®me doit :

- Cr√©er une case en m√©moire appel√©e `pizza`
- Lui donner une valeur par d√©faut au premier chargement du formulaire
- Mettre √† jour cette valeur √† chaque fois que l'utilisateur change son choix dans le `select`
- Si `pizza` vaut `reine`, alors afficher la checkbox de l'oeuf

Et √ßa tombe bien, car React, outre le fait de nous permettre de nous donner du style en jouant aux Lego avec nos composants, vient avec une mani√®re de g√©rer √ßa √† merveille.

Dans React, cette notion de case m√©moire facile √† mettre √† jour, et qui appartient √† un composant en particulier _(pr√©cision pour les devs : propre √† chaque instance d'un composant, qu'il faut voir comme une classe √† instancier),_ √ßa s'appelle le `state`.

Voici √† quoi ressemblerait notre formulaire avec le champ `pizza` contr√¥l√© par un state :

```tsx
import React, { FunctionComponent, useState } from "react";
import styles from "../forms.module.css";
import buildPayloadFromSubmit from "../../lib/buildPayloadFromSubmit";
import axios from "axios";

export type PizzaFormControlledProps = Record<string, never>;

const PizzaFormControlled: FunctionComponent<PizzaFormControlledProps> = () => {
  const [pizza, setPizza] = useState<string>("fromage");

  return (
    <form
      className={styles.form}
      onSubmit={(event) => {
        event.preventDefault();
        const body = buildPayloadFromSubmit(event);
        axios
          .post("https://pizza-api.example.com", body)
          .then((response) => alert(`Commande envoy√©e ! ${response}`))
          .catch((error) => alert(`Outch ! Petit souci : ${error}`));
      }}
    >
      <label htmlFor="prenom">Quel est votre pr√©nom ?</label>
      <input id="prenom" name="prenom" required />

      <label htmlFor="pizza">Quelle pizza d√©sirez-vous ?</label>
      <select
        name="pizza"
        id="pizza"
        value={pizza}
        onChange={(event) => setPizza(event.target.value)}
        onBlur={(event) => setPizza(event.target.value)}
      >
        <option value="fromage">Fromage</option>
        <option value="reine">Reine</option>
        <option value="veggie">Veggie</option>
      </select>

      {pizza === "reine" && (
        <label htmlFor="oeuf">
          <input type="checkbox" name="oeuf" id="oeuf" />
          Et d√©sirez-vous un bel oeuf dessus en prime ?
        </label>
      )}

      <input type="submit" value="Commander !" />
    </form>
  );
};

export default PizzaFormControlled;
```

Explications :

- `const [pizza, setPizza] = useState<string>("fromage");` c'est la ligne qui nous permets de cr√©er une case m√©moire pour ce formulaire, nomm√©e `pizza`, nous donne acc√®s √† `setPizza` qui permets de changer cette valeur, et de la remplir au d√©part par `"fromage"`.
- `onChange={(event) => setPizza(event.target.value)}` sur le `<select>` consiste justement √† "√©couter" l'√©v√®nement de changement de valeur sur ce select. Donc si Marcel choisi "fromage", cette fonction est appel√©e, et on appelle `setPizza` pour lui donner la nouvelle valeur, stock√©e une fois encore dans un objet `event`.
- Et le plus int√©ressant : afficher de mani√®re conditionnelle tout un pan de HTML via `pizza === "reine" &&`. √áa devient un peu plus technique, mais en gros, si la condition est remplie, alors ce qui est pass√© entre parenth√®ses sera affich√©, sinon, √ßa sera comme si √ßa n'avait pas exist√© !

On a donc rempli notre deuxi√®me mission, √† savoir ne pas afficher cette checkbox pour rien. Et √ßa devient tr√®s int√©ressant (si ! si !), car actuellement on n'a contr√¥l√© qu'un seul des champs. Peut-on dire que notre formulaire est contr√¥l√© ? Eh bien, pas vraiment. Enfin, plus exactement, il est partiellement contr√¥l√©.

Eh oui ! Car en r√©alit√©, contr√¥ler ou non un formulaire n'est pas vraiment un choix bool√©en, √ßa peut tr√®s bien √™tre nuanc√©... Et vers la fin on va voir que √ßa peut m√™me √™tre bien plus subtil que √ßa, niark niark niark...

> Un amateur niveau 3 dans les arcanes du d√©veloppement web aura certainement remarqu√© que, m√™me si j'ai maintenant la main sur le `select` en mode contr√¥l√©, cela ne m'emp√™che pas de g√©rer le `onSubmit` directement depuis l'`event` . Notez tout de m√™me que ce n'est pas tr√®s orthodoxe, et qu'√† la prochaine √©tape on va faire les choses plus "proprement", c'est-√†-dire en utilisant directement le state pour construire notre `body`.

## D√©sactiver le bouton tant que le formulaire n'est pas valide

OK ! On y est presque, il nous reste plus qu'√† g√©rer ce petit bouton "Commander !", inutile de laisser Marcel cliquer dessus tant qu'on n'a pas au moins son nom.

Pour la pizza, on a √©t√© malin puisqu'on a une pizza par d√©faut, mais ce qu'on va faire pour le seul champ `pizza` est tout aussi valable pour n'importe quel autre type de champs. √Ä partir du moment o√π vous contr√¥lez totalement le formulaire avec un state, tout est possible.

On va donc :

- ajouter un state pour le champ `prenom`
- tant qu'√† faire, contr√¥ler aussi la checkbox `oeuf`, on pourra alors rev√™tir notre costume de _Texas Ranger_, un brin de paille √† la bouche, et annoncer fi√®rement devant nos coll√®gues que nous _controllons la situation_.
- Griser et rendre inop√©rant le bouton de commande tant qu'on n'a pas un joli pr√©nom de rempli.
- Afficher un joli petit message d'erreur si jamais l'utilisateur essaye quand m√™me de cliquer sur le bouton de commande.

> Cher d√©veloppeur expert React de tous les temps, si tu passes par l√†, ait la gr√¢ce de pardonner mes approximations et l'usage de nom de variables en Fran√ßais (entre autres choses). Ceci est un article tout public...

```tsx
import React, { FunctionComponent, useState } from "react";
import styles from "../forms.module.css";
import axios from "axios";

export type PizzaFormValidatedProps = Record<string, never>;

const PizzaFormValidated: FunctionComponent<PizzaFormValidatedProps> = () => {
  const [prenom, setPrenom] = useState<string>("");
  const [pizza, setPizza] = useState<string>("fromage");
  const [oeuf, setOeuf] = useState<boolean>(false);

  const onPizzaChange = React.useCallback(
    (event: React.ChangeEvent<HTMLSelectElement>) => {
      setPizza(event.target.value);
      // On r√©initialize √† chaque changement de Pizza,
      // sinon Marcel risque de se retrouver avec une Veggie + oeuf...
      setOeuf(false);
    },
    [],
  );

  return (
    <form
      className={styles.form}
      onSubmit={(event) => {
        // On emp√™che le comportement standard du formulaire : recharger la page
        event.preventDefault();
        // On construit nous m√™me un beau body, avec le state du formulaire
        const body = { prenom, pizza, oeuf };
        // On envoie !
        axios
          .post("https://pizza-api.example.com", body)
          .then((response) => alert(`Commande envoy√©e ! ${response}`))
          .catch((error) => alert(`Outch ! Petit souci : ${error}`));
      }}
    >
      <label htmlFor="prenom">Quel est votre pr√©nom ?</label>
      <input
        id="prenom"
        name="prenom"
        value={prenom}
        onChange={(event) => setPrenom(event.target.value)}
      />

      <label htmlFor="pizza">Quelle pizza d√©sirez-vous ?</label>
      <select
        name="pizza"
        id="pizza"
        value={pizza}
        onChange={onPizzaChange}
        onBlur={onPizzaChange}
      >
        <option value="fromage">Fromage</option>
        <option value="reine">Reine</option>
        <option value="veggie">Veggie</option>
      </select>

      {/* On affiche cette option que si la pizza est bien une reine */}
      {pizza === "reine" && (
        <label htmlFor="oeuf">
          <input
            type="checkbox"
            name="oeuf"
            id="oeuf"
            checked={oeuf}
            onChange={() => setOeuf((prevState) => !prevState)}
          />
          Et d√©sirez-vous un bel oeuf dessus en prime ?
        </label>
      )}

      <input
        type="submit"
        value="Commander !"
        // On ne peut pas utiliser le classique `disabled`, sinon le onClick ne sera pas appel√©.
        data-disabled={!prenom}
        onClick={(event) => {
          // On attaque les validations manuelles, de la fa√ßon la plus simpliste possible
          // ne mettez pas ce genre de code en prod ! C'est juste pour l'exemple :)
          if (!prenom) {
            event.preventDefault();
            alert("Il est n√©cessaire d'indiquer un pr√©nom.");
          }
        }}
      />
    </form>
  );
};

export default PizzaFormValidated;
```

Cette fois-ci, j'ai mis mes remarques directement dans le code.

> Notez tout de m√™me qu'il est possible de modifier le style du bouton submit (et m√™me emp√™cher son click) en CSS, en fonction de la validit√© ou non du formulaire selon les attributs des champs (`required`, `pattern`, `type`, etc.).

Il est m√™me possible de rendre tout ou partie du formulaire `disabled` en englobant avec un `<fieldset disabled>` !

Cette fois-ci, on a bien un formulaire totalement contr√¥l√©, avec un syst√®me rudimentaire de validation.

Notez bien que j'essaye de pr√©senter le minimum de code possible. Je fais l'impasse sur plein de d√©tails, il y a des sc√©narios non g√©r√©s, ce formulaire ne sera pas facile √† faire √©voluer, surtout sur les validations. Bref, ce n‚Äôest pas beau. Mais pour expliquer, c'est un d√©but.

Vous comprendrez donc, que m√™me avec un formulaire simple qui pouvait tenir en 27 lignes au d√©part, on se retrouve avec un d√©but de formulaire contr√¥l√© minimaliste qui en fait 90, et qui en ferait facilement 150 si on codait plus proprement.

Outre le nombre de lignes de code, c'est aussi le nombre de cas possibles qu'il faut avoir en t√™te, et √† tester (manuellement ou automatiquement) √† chaque futur changement.

Se poser la question : "est-ce que j'ai vraiment besoin d'un formulaire contr√¥l√©" est donc une question saine.

## Alors, quand a-t-on besoin d'un formulaire contr√¥l√© ? Sacrebleu !

La premi√®re raison qui m'avait pouss√©e jusque l√† √† pr√©f√©rer les formulaires non contr√¥l√©s, c'√©tait pour la performance.

Car en mode contr√¥l√©, ce qu'il faut bien comprendre, c'est que React "recalcule" (`render`) tout le formulaire √† chaque interaction dans les champs. Je clique sur "A" dans le pr√©nom : rerender ! Je s√©lectionne une autre pizza : rerender !

Dans notre petit exemple, c'est totalement b√©nin. Et je pense qu'au final, √† moins d'avoir un formulaire ultra-complexe avec des sous-calculs, √ßa ne devrait pas poser de soucis. La peur du d√©veloppeur, c'est le "lag" √† l'input. Qu'on sente un d√©calage entre le moment o√π je clique sur une lettre et le moment o√π elle s'affiche.

Mais en vrai, il y a peu de chances pour que √ßa se produise.

Aujourd'hui, ce qui me pla√Æt le plus dans un formulaire non contr√¥l√©, c'est sa simplicit√©.

Les navigateurs supportent tous les jours de nouveaux attributs, de nouvelles fa√ßons d'√©crire du HTML. Et on peut aller vraiment tr√®s loin avec un basique formulaire HTML, √† la limite en attrapant juste au vol le submit.

De plus, il existe d'autres fa√ßons d'avoir les b√©n√©fices des 2 approches, c'est le cas par exemple de la lib `react-hook-form` qui permet d'utiliser des champs non contr√¥l√©s, mais qui √©coute tout de m√™me les √©v√®nements via ce qu'on appelle les `ref`. Le formulaire a un state global plus complexe, capable de re-render uniquement dans certaines conditions de notre choix (quand on modifie la pizza par exemple).

C'est vraiment tr√®s malin comme fa√ßon de faire, surtout que √ßa n'emp√™che pas de rajouter une couche de state global au cas par cas, si jamais on rentre dans une limite de la lib.

Je vais surement d√©cevoir, mais je pense que la r√©ponse √† cette question, est comme souvent : √ßa d√©pend !

- Est-ce que le designer ou la spec pr√©voit des choses un peu velues sur l'UX ?
- Est-ce que la team est √† l'aise avec telle ou telle fa√ßon de faire ?
- Est-ce qu'il y a des probl√®mes de perfs sur un formulaire ?
- Est-ce que la structure du formulaire est d√©crite en dur √† l'avance ou bien est-il g√©n√©r√© en fonction d'un JSON re√ßu ?
- Jusqu'√† quel point on veut le typer via TypeScript (champs, sch√©ma de validation) ?

Cela fait peu de temps que j'ai d√©couvert react-hook-form, et je suis donc probablement biais√© par le plaisir de la d√©couverte, mais je trouve que leur approche est la bonne. Je vais probablement pousser plus loin ma recherche dans l'utilisation de cette lib.

> Si vous d√©sirez jouer avec le code en question, c'est [tout sur github !](https://github.com/tidusia/create-react-app-demos/tree/to-control-or-not-to-control)
